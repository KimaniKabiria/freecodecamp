<!--
  vim: ft=html:
  GENERATED CODE: DO NOT EDIT
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>AIRPS/ |  FreeCodeCamp solutions</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"
    />

    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 800px;
        margin: 0 auto;
        padding: 45px;
        border: solid 1px lightgray;
        border-radius: 5px;
        box-shadow: 1px 1px 3px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }

      a[href*="//"] {
        background: url(https://upload.wikimedia.org/wikipedia/commons/6/64/Icon_External_Link.png)
          center right no-repeat;
        padding-right: 13px;
      }
    </style>
  </head>
  <body>
    <article class="markdown-body">
      <h1 id="rock-paper-scissors">Rock Paper Scissors</h1>
<h2 id="note">Note</h2>
<p><strong>Have no idea</strong>. Need to learn this more serious.</p>
<h3 id="think-like-fcc">Think like FCC</h3>
<p>I was really tempted to look into the game driver code and learn about
how other players is implemented, but I didn&#39;t</p>
<p>Since we&#39;re not suppose to look in the opponent implementations, let&#39;s
think about how would FCC implement them.</p>
<ul>
<li><strong>Completely random</strong>: this is a no, because if so, we have no way to
predict.</li>
<li><strong>Favor a kind of move</strong> more than the other 2: this is possible, we
will need to calculate the statistic to find the favored items.</li>
<li><strong>Favor but never repeat</strong>, similar with above, but opponent will never
use same move continuously more than <code>n</code> times.</li>
<li><strong>Counter move</strong>, for example, if his previous move is <code>R</code>, the opponent
might &quot;think&quot; that we want to play <code>P</code> next, so he play <code>S</code>. For this
case, we should use the same with opponent previous move. I don&#39;t think
FCC would implement such logic, as it&#39;s too simple, no random</li>
<li><strong>Repetitive</strong>, basically just repeat a list of moves.</li>
<li><strong>Random but never repeat</strong>, there&#39;s could be other variants like accept
maximum 2 or 3 repeats.</li>
<li><strong>Repeat before next random</strong>, a series of <code>n</code> repeated <code>R</code>, then pick
randomly next move and repeat them <code>n</code> times.</li>
<li><strong>Multi strategy</strong>, perhaps one of the 4 bots is can perform all above
strategies, and will switch when he lose a lot.</li>
</ul>
<h3 id="implementation-ideas">Implementation ideas</h3>
<p>For each strategy our opponent can employ, we should have a counter
strategy. We will need to use random move for a while, until we have
enougb data to see his strategy.</p>
<p>However, since this is just a game, I don&#39;t think we should try to be
perfect and implement all ideas we have. We will just add enough code
until we beat all the bots.</p>
<p>That means the code in the <a href="#Solution">Solution</a> section below doesn&#39;t
grow linearly.</p>
<h2 id="problem">Problem</h2>
<h3 id="assignment">Assignment</h3>
<p>For this challenge, you will create a program to play Rock, Paper, Scissors.
A program that picks at random will usually win 50% of the time. To pass
this challenge your program must play matches against four different bots,
winning at least 60% of the games in each match.</p>
<p>In the file <code>RPS.py</code> you are provided with a function called <code>player</code>. The
function takes an argument that is a string describing the last move of the
opponent (&quot;R&quot;, &quot;P&quot;, or &quot;S&quot;). The function should return a string
representing the next move for it to play (&quot;R&quot;, &quot;P&quot;, or &quot;S&quot;).</p>
<p>A player function will receive an empty string as an argument for the first
game in a match since there is no previous play.</p>
<p>The file <code>RPS.py</code> shows an example function that you will need to update.
The example function is defined with two arguments
(<code>player(prev_play, opponent_history = [])</code>). The function is never called
with a second argument so that one is completely optional. The reason why
the example function contains a second argument (<code>opponent_history = []</code>) is
because that is the only way to save state between consecutive calls of the
<code>player</code> function. You only need the <code>opponent_history</code> argument if you want
to keep track of the opponent_history.</p>
<p><em>Hint: To defeat all four opponents, your program may need to have multiple
strategies that change depending on the plays of the opponent.</em></p>
<h3 id="development">Development</h3>
<p>Do not modify <code>RPS_game.py</code>. Write all your code in <code>RPS.py</code>. For
development, you can use <code>main.py</code> to test your code.</p>
<p><code>main.py</code> imports the game function and bots from <code>RPS_game.py</code>.</p>
<p>To test your code, play a game with the <code>play</code> function. The <code>play</code> function
takes four arguments:</p>
<ul>
<li>two players to play against each other (the players are actually
functions)</li>
<li>the number of games to play in the match</li>
<li>an optional argument to see a log of each game. Set it to <code>True</code> to see
these messages.</li>
</ul>
<pre><code class="language-py">play(player1, player2, num_games[, verbose])
</code></pre>
<p>For example, here is how you would call the function if you want <code>player</code>
and <code>quincy</code> to play 1000 games against each other and you want to see the
results of each game:</p>
<pre><code class="language-py">play(player, quincy, 1000, verbose=True)
</code></pre>
<h2 id="solution">Solution</h2>
<pre><code class="language-python">import random
from collections import Counter
</code></pre>
<p>Map between a move and its counter.</p>
<pre><code class="language-python">counter_move = {&quot;R&quot;: &quot;P&quot;, &quot;P&quot;: &quot;S&quot;, &quot;S&quot;: &quot;R&quot;}
</code></pre>
<p>This is our random move picker</p>
<pre><code class="language-python">def rand_move():
    moves = [&quot;R&quot;, &quot;P&quot;, &quot;S&quot;]
    i = random.randint(0, 2)
    return moves[i]
</code></pre>
<p>Counter strategy for <strong>Favor</strong>. This beat one of the bot.</p>
<pre><code class="language-python">def counter_favor(total: int, freq: Counter) -&gt; str:
    next_move_id = random.randint(0, total)

    our = &quot;R&quot;
    if 0 &lt;= next_move_id &lt; freq[&quot;R&quot;]:
        our = &quot;P&quot;
    elif freq[&quot;R&quot;] &lt;= next_move_id &lt; freq[&quot;R&quot;] + freq[&quot;P&quot;]:
        our = &quot;S&quot;

    if random.randint(0, 2) % 2 != 0:
        our = counter_move[our]

    return our
</code></pre>
<p>Counter strategy for <strong>Favor no repeat</strong>. This beat one of the bot.</p>
<pre><code class="language-python">def counter_favor_no_repeat(total: int, prev: str, freq: Counter) -&gt; str:
    next_move_id = random.randint(0, total)

    guess = &quot;R&quot;
    if 0 &lt;= next_move_id &lt;= freq[&quot;R&quot;]:
        guess = &quot;P&quot;
    elif freq[&quot;R&quot;] &lt;= next_move_id &lt;= freq[&quot;R&quot;] + freq[&quot;P&quot;]:
        guess = &quot;S&quot;

    if guess == prev:
        guess = counter_move[counter_move[guess]]

    return guess
</code></pre>
<p>Our player implementation</p>
<pre><code class="language-python">def player(prev_play, opponent_history=[]):
    opponent_history.append(prev_play)
    hist = opponent_history
    freq = Counter(opponent_history)
    total = sum(freq.values())

    # if we don&#39;t have enough data to guess,
    # or previous play is invalid,
    # then just play randomly
    if total &lt; 10 or prev_play == &quot;&quot;:
        return rand_move()

    # if there&#39;s a repetitive patterns of recently moves,
    # use our counter strategy.
    rev_hist = list(reversed(hist))
    n = 3
    is_hist_repeat = all(
        rev_hist[i * n : (i + 1) * n] == rev_hist[0:n]
        for i in range(1, int(total / n))
    )
    if is_hist_repeat:
        return counter_move[rev_hist[1]]

    almost_random = any([0.35 &gt;= p / total &gt;= 0.32 for p in freq.values()])
    never_repeat = all([hist[i] != hist[i - 1] for i in range(0, total)])
    if almost_random and never_repeat:
        return rand_move()

    # if we found any move that appears more frequently than other,
    # use our counter strategy
    if any([p / total &gt; 0.4 for p in freq.values()]):
        if never_repeat:
            return counter_favor_no_repeat(total, prev_play, freq)
        else:
            return counter_favor(total, freq)

    # if opponent always try to counter his previous move
    # doesn&#39;t work
    # is_self_counter = all(
    #     [hist[i] == counter_move[hist[i - 1]]
    #      for i in range(total - 1, total - 10, -1)]
    # )
    # if is_self_counter:
    #     return counter_move[counter_move[prev_play]]

    return counter_move[prev_play]
</code></pre>
<h2 id="game-driver">Game driver</h2>
<p>This is provided by FCC.</p>
<pre><code class="language-python">def play(player1, player2, num_games, verbose=False):
    p1_prev_play = &quot;&quot;
    p2_prev_play = &quot;&quot;
    results = {&quot;p1&quot;: 0, &quot;p2&quot;: 0, &quot;tie&quot;: 0}

    for _ in range(num_games):
        p1_play = player1(p2_prev_play)
        p2_play = player2(p1_prev_play)

        if p1_play == p2_play:
            results[&quot;tie&quot;] += 1
            winner = &quot;Tie.&quot;
        elif (
            (p1_play == &quot;P&quot; and p2_play == &quot;R&quot;)
            or (p1_play == &quot;R&quot; and p2_play == &quot;S&quot;)
            or (p1_play == &quot;S&quot; and p2_play == &quot;P&quot;)
        ):
            results[&quot;p1&quot;] += 1
            winner = &quot;Player 1 wins.&quot;
        elif (
            p2_play == &quot;P&quot;
            and p1_play == &quot;R&quot;
            or p2_play == &quot;R&quot;
            and p1_play == &quot;S&quot;
            or p2_play == &quot;S&quot;
            and p1_play == &quot;P&quot;
        ):
            results[&quot;p2&quot;] += 1
            winner = &quot;Player 2 wins.&quot;

        if verbose:
            print(&quot;Player 1:&quot;, p1_play, &quot;| Player 2:&quot;, p2_play)
            print(winner)
            print()

        p1_prev_play = p1_play
        p2_prev_play = p2_play

    games_won = results[&quot;p2&quot;] + results[&quot;p1&quot;]

    if games_won == 0:
        win_rate = 0
    else:
        win_rate = results[&quot;p1&quot;] / games_won * 100

    print(&quot;Final results:&quot;, results)
    print(f&quot;Player 1 win rate: {win_rate}%&quot;)

    return win_rate
</code></pre>
<pre><code class="language-python">def quincy(prev_play, counter=[0]):
    counter[0] += 1
    choices = [&quot;R&quot;, &quot;R&quot;, &quot;P&quot;, &quot;P&quot;, &quot;S&quot;]
    return choices[counter[0] % len(choices)]
</code></pre>
<pre><code class="language-python">def mrugesh(prev_opponent_play, opponent_history=[]):
    opponent_history.append(prev_opponent_play)
    last_ten = opponent_history[-10:]
    most_frequent = max(set(last_ten), key=last_ten.count)

    if most_frequent == &quot;&quot;:
        most_frequent = &quot;S&quot;

    ideal_response = {&quot;P&quot;: &quot;S&quot;, &quot;R&quot;: &quot;P&quot;, &quot;S&quot;: &quot;R&quot;}
    return ideal_response[most_frequent]
</code></pre>
<pre><code class="language-python">def kris(prev_opponent_play):
    if prev_opponent_play == &quot;&quot;:
        prev_opponent_play = &quot;R&quot;
    ideal_response = {&quot;P&quot;: &quot;S&quot;, &quot;R&quot;: &quot;P&quot;, &quot;S&quot;: &quot;R&quot;}
    return ideal_response[prev_opponent_play]
</code></pre>
<pre><code class="language-python">def abbey(
    prev_opponent_play,
    opponent_history=[],
    play_order=[
        {
            &quot;RR&quot;: 0,
            &quot;RP&quot;: 0,
            &quot;RS&quot;: 0,
            &quot;PR&quot;: 0,
            &quot;PP&quot;: 0,
            &quot;PS&quot;: 0,
            &quot;SR&quot;: 0,
            &quot;SP&quot;: 0,
            &quot;SS&quot;: 0,
        }
    ],
):
    if not prev_opponent_play:
        prev_opponent_play = &quot;R&quot;
    opponent_history.append(prev_opponent_play)

    last_two = &quot;&quot;.join(opponent_history[-2:])
    if len(last_two) == 2:
        play_order[0][last_two] += 1

    potential_plays = [
        prev_opponent_play + &quot;R&quot;,
        prev_opponent_play + &quot;P&quot;,
        prev_opponent_play + &quot;S&quot;,
    ]

    sub_order = {
        k: play_order[0][k] for k in potential_plays if k in play_order[0]
    }

    prediction = max(sub_order, key=sub_order.get)[-1:]

    ideal_response = {&quot;P&quot;: &quot;S&quot;, &quot;R&quot;: &quot;P&quot;, &quot;S&quot;: &quot;R&quot;}
    return ideal_response[prediction]
</code></pre>
<pre><code class="language-python">def human(prev_opponent_play):
    play = &quot;&quot;
    while play not in [&quot;R&quot;, &quot;P&quot;, &quot;S&quot;]:
        play = input(&quot;[R]ock, [P]aper, [S]cissors? &quot;)
        print(play)
    return play
</code></pre>
<pre><code class="language-python">def random_player(prev_opponent_play):
    return random.choice([&quot;R&quot;, &quot;P&quot;, &quot;S&quot;])
</code></pre>
<h2 id="playground">Playground</h2>
<pre><code class="language-python"># play(player, quincy, 1000) # hist repeat
# play(player, mrugesh, 1000) # hist repeat
play(player, abbey, 1000)
# play(player, kris, 1000)
</code></pre>
<pre><code>Final results: {&#39;p1&#39;: 489, &#39;p2&#39;: 477, &#39;tie&#39;: 34}
Player 1 win rate: 50.621118012422365%





50.621118012422365
</code></pre>
<h2 id="test">Test</h2>

    </article>

    <a
      target="_blank"
      href="https://github.com/letientai299/freecodecamp"
      class="github-corner"
      aria-label="View source on GitHub"
      ><svg
        width="80"
        height="80"
        viewBox="0 0 250 250"
        style="position: absolute; top: 0; border: 0; right: 0;"
        aria-hidden="true"
      >
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="white"
          style="transform-origin: 130px 106px;"
          class="octo-arm"
        ></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="white"
          class="octo-body"
        ></path></svg></a
    ><style>
      .github-corner svg {
        fill: black;
        color: white;
      }

      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
      @keyframes octocat-wave {
        0%,
        100% {
          transform: rotate(0);
        }
        20%,
        60% {
          transform: rotate(-25deg);
        }
        40%,
        80% {
          transform: rotate(10deg);
        }
      }
      @media (max-width: 500px) {
        .github-corner:hover .octo-arm {
          animation: none;
        }
        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
      }
    </style>
  </body>
</html>
